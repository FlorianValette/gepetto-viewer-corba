//
//  client-cpp.cc
//  C++ CORBA client interface for SceneViewer
//
//  Created by Mathieu Geisert in December 2014.
//  Copyright (c) 2014 LAAS-CNRS. All rights reserved.
//

#include "client-cpp.hh"

namespace Graphics { 
namespace corbaServer {

void ClientCpp::se3ToCorba(CORBA::Double* corbaPosition, const se3::SE3& se3position)
{
    Eigen::Quaternion<double> q(se3position.rotation());
    corbaPosition[0] = se3position.translation()(0);
    corbaPosition[1] = se3position.translation()(1);
    corbaPosition[2] = se3position.translation()(2);    
    corbaPosition[3] = q.w();
    corbaPosition[4] = q.x();
    corbaPosition[5] = q.y();
    corbaPosition[5] = q.z();        
}


ClientCpp::ClientCpp()
{
    int    argc=0;       // Dummy variables to support following call.
    char** argv=0;
    orb_ = CORBA::ORB_init(argc, argv);

    // Get a reference to the Naming Service
    CORBA::Object_var rootContextObj = 
        orb_->resolve_initial_references("NameService");
    CosNaming::NamingContext_var nc =
	CosNaming::NamingContext::_narrow(rootContextObj.in());

    CosNaming::Name name;
    name.length(2);
    name[0].id = (const char *) "Graphics";
    name[0].kind = (const char *) "corbaserver";
    name[1].id = (const char *) "basic";
    name[1].kind = (const char *) "graphicalinterface";
    // Invoke the root context to retrieve the object reference
    CORBA::Object_var managerObj = nc->resolve(name);
    // Narrow the previous object to obtain the correct type
    manager_ = Graphics::corbaserver::Graphicalinterface::_narrow(managerObj.in());
}

ClientCpp::~ClientCpp()
{
    //manager_->shutdown();
    if (!CORBA::is_nil(orb_)) {
	try {
	    orb_->destroy();
	    std::cout << "Ending CORBA..." << std::endl;
	} catch(const CORBA::Exception& e) {
	    std::cout << "orb->destroy failed" << std::endl;
	}
    }
}

void ClientCpp::getNodeList()
{
   manager_->getNodeList();
}


void ClientCpp::getWindowList()
{
   manager_->getWindowList();
}

bool ClientCpp::setRate(int  rate)
{
   return manager_->setRate(rate);
}

void ClientCpp::refresh()
{
    manager_->refresh();
}

bool ClientCpp::createWindow(const char* windowName)
{
    return manager_->createWindow(windowName);
}


    //void ClientCpp::createWindow(const char* name, CORBA::ULong x, CORBA::ULong y, CORBA::ULong width, CORBA::ULong height) ;

bool ClientCpp::createScene(const char* sceneName)
{
    return manager_->createScene(sceneName);
}

bool ClientCpp::createSceneWithFloor(const char* sceneName)
{
    return manager_->createSceneWithFloor(sceneName);
}

bool ClientCpp::addSceneToWindow(const char* sceneName, const char* windowName)
{
   return  manager_->addSceneToWindow(sceneName, windowName);
}

    //void ClientCpp::addBox(const char* boxName, float boxSize1, float boxSize2, float boxSize3, const char* colorName);

bool ClientCpp::addBox(const char* boxName, float boxSize1, float boxSize2, float boxSize3)
{
    return manager_->addBox(boxName, boxSize1, boxSize2, boxSize3);
}

bool ClientCpp::addCapsule(const char* capsuleName, float radius, float height)
{
    return manager_->addCapsule(capsuleName, radius, height);
}

    //void ClientCpp::addCapsule(const char* capsuleName, float radius, float height, const char* colorName);

bool ClientCpp::addMesh(const char* meshName, const char* meshPath)
{
    return manager_->addMesh(meshName, meshPath);
}

bool ClientCpp::addCone(const char* coneName, float radius, float height)
{
    return manager_->addCone(coneName, radius, height);
}

    //void ClientCpp::addCone(const char* coneName, float radius, float height, const char* colorName);

bool ClientCpp::addCylinder(const char* cylinderName, float radius, float height)
{
    return manager_->addCylinder(cylinderName, radius, height);
}

    //void ClientCpp::addCylinder(const char* cylinderName, float radius, float height, const char* colorName);

bool ClientCpp::addSphere(const char* sphereName, float radius)
{
    return manager_->addSphere(sphereName, radius);
}

    //void ClientCpp::addSphere(const char* sphereName, float radius, const char* colorName);

bool ClientCpp::addURDF(const char* urdfName, const char* urdfPath, const char* urdfPackagePath)
{
    return manager_->addURDF(urdfName, urdfPath, urdfPackagePath);
}

bool ClientCpp::createGroup(const char* groupName)
{
    return manager_->createGroup(groupName);
}

bool ClientCpp::addToGroup(const char* nodeName, const char* groupName)
{
    return manager_->addToGroup(nodeName, groupName);
}

bool ClientCpp::applyConfiguration(const char* nodeName, const se3::SE3& se3position)
{
    CORBA::Double corbaPosition[7];
    ClientCpp::se3ToCorba(corbaPosition, se3position);
    return manager_->applyConfiguration(nodeName, corbaPosition);
}

bool ClientCpp::setVisibility(const char* nodeName, const char* visibilityMode)
{
    return manager_->setVisibility(nodeName, visibilityMode);
}

bool ClientCpp::setWireFrameMode(const char* nodeName, const char* wireFrameMode)
{
    return manager_->setWireFrameMode(nodeName, wireFrameMode);
}
bool ClientCpp::setLightingMode(const char* nodeName, const char* lightingMode)
{
    return manager_->setLightingMode(nodeName, lightingMode);
}

} // end of namespace corbaserver
} // end of namespace Graphics
